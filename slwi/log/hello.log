Script started on 2021-01-02 16:08:46+09:00 [TERM="linux" TTY="/dev/tty1" COLUMNS="170" LINES="48"]
[?2004h[qha@ljmljat slwi]$ script -v[K[K[K[K[K[K[K[K[Ksh -vx slwi.sh 
[?2004l#!/bin/sh

:<<-'VERSION'

slwi.sh -- itflabtijtslwi interpreter

- AWK script

written by GH-TpaeFawzen on 2021/01/02 

VERSION
+ :

set -eu # exit on error and undefined variable
+ set -eu
umask 0022
+ umask 0022
export LC_ALL=C # locale has to be default
+ export LC_ALL=C
type getconf >/dev/null 2>&1 &&
type command >/dev/null 2>&1 &&
export PATH="$(command -p getconf PATH)${PATH+:}${PATH-}"
+ type getconf
+ type command
+ command -p getconf PATH
+ export PATH=/bin:/usr/bin:/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/lib/jvm/default/bin:/usr/bin/site_perl:/usr/bin/vendor_perl:/usr/bin/core_perl
export UNIX_STD=2003 # for HP-UX
+ export UNIX_STD=2003

usagex(){
	cat <<-'USAGE'
	Usage: ${0##*/} [-d[1|2]] [FILE]
	Option:
	  -d: debug mode; outputs the program when below, to STDERR.
	      (default: -d2)
	    -d1: whenever program itself produce an output.
	    -d2: before each step.
	Argument:
	  FILE: itflabtijtslwi program source file.
	Note:
	  FILE can be omitted, or one of the following values:
	    -
	    /dev/stdin
	    /dev/fd/0
	    /proc/self/fd/0
	  to let the program be read from STDIN.
	  FILE may begin with hyphen.
	USAGE
	exit 1
}
errorx(){
	printf '%s\n' "${0##*/}: ${2:?Missing error message}" 1>&2
	exit "${1:?Missing exit code}"
}

# debug mode?
debug=0
+ debug=0
case "${1-}" in ('-d'|'-d'[12])
	set -- "${1#-d}" "$@"
	debug=${1:+2}
	shift 2
esac

# look for itflabtijtslwi source file.
case "${1-}" in (''|'-'|'/dev/stdin'|'/dev/fd/0'|'/proc/self/fd/0')
	set --
;;(*)
	{
		test -f "$1" ||
		test -c "$1" ||
		test -p "$1"
    } && {
		test -r "$1" ||
		errorx 1 "$1: Cannot read the file"
	}
	test -d "$1" &&
		errorx 1 "$1: Is a directory"
esac
+ set --

# make sure a file whose name begin with hyphen should be
# parsed correctly
case "${1-}" in (''|'/'*|'./'*|'../'*)
	:
;;(*)
	set -- "./$1"
esac
+ :

# constants
readonly slashO=$( printf /  | od -A n -t o1 -v | tr -Cd 01234567 )
+ printf /
+ od -A n -t o1 -v
+ tr -Cd 01234567
+ readonly slashO=057
readonly bslshO=$( printf \\ | od -A n -t o1 -v | tr -Cd 01234567 )
+ printf \
+ od -A n -t o1 -v
+ tr -Cd 01234567
+ readonly bslshO=134
readonly gO=$(     printf G  | od -A n -t o1 -v | tr -Cd 01234567 )
+ printf G
+ od -A n -t o1 -v
+ tr -Cd 01234567
+ readonly gO=107

# make temporary directory
mktd(){
readonly fnamec=$(
	tr -d \\012 <<-CHARS
	1234567890
	qwertyuiopasdfghjklzxcvbnm
	QWERTYUIOPASDFGHJKLZXCVBNM_
	CHARS
)
test -c /dev/urandom &&
	set -- $(
		strings /dev/urandom |
		tr -Cd "$fnamec" |
		dd bs=14 count=1 2>/dev/null
	) ||
	set -- $(
		(
			ps -Ao pid,etime,pcpu,vsz
			date
		) |
		# generate <=42 eight-digit decimals
		od -A n -t d4 -v |
		tr -Cs 0123456789 \\012 |
		grep [0-9] |
		tail -n 42 |
		sed 's,.*\(........\)$,\1,' |
		# generate filename randomly
		awk '
		BEGIN{a=-(2**31);}
		{a+=$0;}
		END{
			srand(a);
			c="'"$fnamec"'";
			L=length(c);
			l=14;
			for(i=1;i<=l;i++){
				j=int(rand()*L)+1;
				p=substr(c,j,1);
				printf p;
			}
		}'
	)
test -e "$1" &&
	errorx 2 \
		'Temporary directory could not be made; please try again'

#(umask 0177; touch "$1")
#(umask 0177; mkdir "$1")
(umask 0077; mkdir "$1")
printf %s\\n "$1"
}

# main process below
# ã‚‚ã—ã‚‚ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒæ¨™æº–å…¥åŠ›ã§ã‹ã¤ã‚¼ãƒ­ç•ªã¸ã®ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆãŒãªã‘ã‚Œã°äºŒå›žEOFã‚’èª­ã‚€ã¾ã§
# ä¸€æ–¹ã§æ¨™æº–å…¥åŠ›ã§ã‚¼ãƒ­ç•ªã¸ã®ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆãŒã‚ã‚Œã°ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¸ã®å…¥åŠ›ã¯ãªã—
# ã‚ã¨ã¯ã„ã„ã ã‚?

# program: from STDIN
# program input: from terminal
if
	case "$#" in (0) test -t 0
	;;(*) false
	esac
then
	tmp="$(mktd)"
	# make sure to remove temporary directory
	trap "rm -rf $tmp" INT QUIT KILL ABRT
	
	# plscont="${tmp}/c.$$"
	# : >"$plscont"
	plsdie="${tmp}/d.$$"
	plsread="${tmp}/r.$$"

	{
		# read program
		od -A n -t o1 -v |
		tr -Cd 01234567\\012 |
		sed 's/.../&X/g' |
		tr -d \\012
		echo
		# no more program
		# echo EOP
		# read input on demand
		while :; do
			# test -e "$plscont" || break
			test -e "$plsdie" && break
			test -e "$plsread" || continue
			if IFS= read -r l; then
				# with LF
				printf %s\\n "$l" |
				od -A n -t o1 -v |
				tr -Cd 01234567\\012 |
				sed 's/.../&X/g' |
				tr -d \\012
				echo
				rm "$plsread"
			else
				# without LF
				printf %s "$l" | 
				od -A n -t o1 -v |
				tr -Cd 01234567\\012 |
				sed 's/.../&X/g' |
				tr -d \\012
				echo
				break # because reached to EOF
			fi
		done
		# no more input
	} |
	# itflabtijtslwi interpreter
	awk -v s="${slashO}X" \
	    -v b="${bslshO}X" \
	    -v gg="${gO}X${gO}X" \
	    -v plsread="$plsread" \
	    -v plsdie="$plsdie" \
	'BEGIN{
		# # read program
		# program="";
		# 	for(getline;$0!="EOP";getline)
		# program=program $0;

		# read program
		getline program;
		
		# now process program
		input     = "";
		eoi       = "notyet"; # or "reached"
		mode      = "quine"; # or "pattern" or "replace" or "ipattern"
		pattern   = "";
		replace   = "";
		ipattern  = "";
		for(;;){
			'"$(
			case "$debug" in (2) cat <<-'DEBUG2'
			printf "[%s]\n",program >"/dev/stderr";
			DEBUG2
			esac
			)"'

			if(program==""){
				break;
			}

			if(                  program==b            ){
				break;
			}
			if(mode=="quine"   &&program~("^" b "...X")){
				print substr(program,5,4);
				program=substr(program,9);
			}
			if(mode=="pattern" &&program~("^" b "...X")){
				pattern=pattern substr(program,5,4);
				program=substr(program,9);
			}
			if(mode=="replace" &&program~("^" b "...X")){
				replace=replace substr(program,5,4);
				program=substr(program,9);
			}
			if(mode=="ipattern"&&program~("^" b "...X")){
				ipatern=ipattern substr(program,5,4);
				program=substr(program,9);
			}

			if(mode=="quine"  &&program~("^" s)){
				program=substr(program,5);
				mode="pattern";
			}
			if(mode=="pattern"&&program~("^" s)){
				program=substr(program,5);
				mode="replace";
			}
			if(mode=="replace"&&program~("^" s)){
				while(pattern==""){
					# get trapped here
				}
				program=substr(program,5);
				while(program~pattern){
					sub(pattern,replace,program);
				}
				pattern="";
				replace="";
				mode="quine";
			}

			if(mode=="quine"   &&program~("^" gg)){
				program=substr(program,9);
				mode="ipattern";
			}
			if(mode=="ipattern"&&program~("^" gg)&&eoi=="notyet" ){
				if(input==""){
					printf "">plsread;
					_=getline input;
					if(!_){
						eoi="reached";
						replace="";
					}else{
						replace=substr(input,1,4);
						input=substr(input,5);
					}
				}else{
					replace=substr(input,1,4);
					input=substr(input,5);
				}
				while(ipattern==""){
					# get trapped here
				}
				program=substr(program,9);
				while(program~ipattern){
					sub(ipattern,replace,program);
				}
				ipattern="";
				replace="";
				mode="quine";
			}
			if(mode=="ipattern"&&program~("^" gg)&&eoi=="reached"){
				while(ipattern==""){
					# get trapped here
				}
				program=substr(program,9);
				replace="";
				while(program~ipattern){
					sub(ipattern,replace,program);
				}
				ipattern="";
				mode="quine";
			}

			if(mode=="quine"   &&program!~("^(" s "|" b "|" gg ")")){
				print substr(program,1,4);
				program=substr(program,5);
			}
			if(mode=="pattern" &&program!~("^(" s "|" b        ")")){
				pattern=pattern substr(program,1,4);
				program=substr(program,5);
			}
			if(mode=="replace" &&program!~("^(" s "|" b        ")")){
				replace=replace substr(program,1,4);
				program=substr(program,5);
			}
			if(mode=="ireplace"&&program!~("^("       b "|" gg ")")){
				ireplace=ireplace substr(program,1,4);
				program=substr(program,5);
			}
		}

		printf"">plsdie;
	}' |
		tee |
	sed 's/\(...\)X/\\\\\1/g' |
	xargs -n 1 printf
fi
+ test -t 0
+ mktd
+ tr -d \012
+ readonly fnamec=1234567890qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM_
+ test -c /dev/urandom
+ strings /dev/urandom
+ tr -Cd 1234567890qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM_
+ dd bs=14 count=1
+ set -- jYiQg7vKjRNlO0
+ test -e jYiQg7vKjRNlO0
+ umask 0077
+ mkdir jYiQg7vKjRNlO0
+ printf %s\n jYiQg7vKjRNlO0
+ tmp=jYiQg7vKjRNlO0
+ trap rm -rf jYiQg7vKjRNlO0 INT QUIT KILL ABRT
+ plsdie=jYiQg7vKjRNlO0/d.1223
+ plsread=jYiQg7vKjRNlO0/r.1223
+ + od -A ntee -t
 o1 -v
+ tr -Cd 01234567\012
+ + xargs -n 1awk printf -v
 s=057X -v b=134X -v gg=107X107X -v+  plsread=jYiQg7vKjRNlO0/r.1223 -v plsdie=jYiQg7vKjRNlO0/d.1223+ tr -d \012 BEGIN{
		# # read program
		# program="";
		# 	for(getline;$0!="EOP";getline)
		# program=program $0;

		# read program
		getline program;
		
		# now process program
		input     = "";
		eoi       = "notyet"; # or "reached"
		mode      = "quine"; # or "pattern" or "replace" or "ipattern"
		pattern   = "";
		replace   = "";
		ipattern  = "";
		for(;;){
			

			if(program==""){
				break;
			}

			if(                  program==b            ){
				break;
			}
			if(mode=="quine"   &&program~("^" b "...X")){
				print substr(program,5,4);
				program=substr(program,9);
			}
			if(mode=="pattern" &&program~("^" b "...X")){
				pattern=pattern substr(program,5,4);
				program=substr(program,9);
			}
			if(mode=="replace" &&program~("^" b "...X")){
				replace=replace substr(program,5,4);
				program=substr(program,9);
			}
			if(mode=="ipattern"&&program~("^" b "...X")){
				ipatern=ipattern substr(program,5,4);
				program=substr(program,9);
			}

			if(mode=="quine"  &&program~("^" s)){
				program=substr(program,5);
				mode="pattern";
			}
			if(mode=="pattern"&&program~("^" s)){
				program=substr(program,5);
				mode="replace";
			}
			if(mode=="replace"&&program~("^" s)){
				while(pattern==""){
					# get trapped here
				}
				program=substr(program,5);
				while(program~pattern){
					sub(pattern,replace,program);
				}
				pattern="";
				replace="";
				mode="quine";
			}

			if(mode=="quine"   &&program~("^" gg)){
				program=substr(program,9);
				mode="ipattern";
			}
			if(mode=="ipattern"&&program~("^" gg)&&eoi=="notyet" ){
				if(input==""){
					printf "">plsread;
					_=getline input;
					if(!_){
						eoi="reached";
						replace="";
					}else{
						replace=substr(input,1,4);
						input=substr(input,5);
					}
				}else{
					replace=substr(input,1,4);
					input=substr(input,5);
				}
				while(ipattern==""){
					# get trapped here
				}
				program=substr(program,9);
				while(program~ipattern){
					sub(ipattern,replace,program);
				}
				ipattern="";
				replace="";
				mode="quine";
			}
			if(mode=="ipattern"&&program~("^" gg)&&eoi=="reached"){
				while(ipattern==""){
					# get trapped here
				}
				program=substr(program,9);
				replace="";
				while(program~ipattern){
					sub(ipattern,replace,program);
				}
				ipattern="";
				mode="quine";
			}

			if(mode=="quine"   &&program!~("^(" s "|" b "|" gg ")")){
				print substr(program,1,4);
				program=substr(program,5);
			}
			if(mode=="pattern" &&program!~("^(" s "|" b        ")")){
				pattern=pattern substr(program,1,4);
				program=substr(program,5);
			}
			if(mode=="replace" &&program!~("^(" s "|" b        ")")){
				replace=replace substr(program,1,4);
				program=substr(program,5);
			}
			if(mode=="ireplace"&&program!~("^("       b "|" gg ")")){
				ireplace=ireplace substr(program,1,4);
				program=substr(program,5);
			}
		}

		printf"">plsdie;
	}
sed
 s/.../&X/g
+ sed s/\(...\)X/\\\\\1/g
Hello, world!
+ echo
+ :
+ test -e jYiQg7vKjRNlO0/d.1223
+ test -e jYiQg7vKjRNlO0/r.1223
+ continue
+ :
+ test -e jYiQg7vKjRNlO0/d.1223
+ test -e jYiQg7vKjRNlO0/r.1223
+ continue
+ :
+ test -e jYiQg7vKjRNlO0/d.1223
+ test -e jYiQg7vKjRNlO0/r.1223
+ continue
+ :
+ test -e jYiQg7vKjRNlO0/d.1223
+ test -e jYiQg7vKjRNlO0/r.1223
+ continue
+ :
+ test -e jYiQg7vKjRNlO0/d.1223
+ test -e jYiQg7vKjRNlO0/r.1223
+ continue
+ :
+ test -e jYiQg7vKjRNlO0/d.1223
+ test -e jYiQg7vKjRNlO0/r.1223
+ continue
+ :
+ test -e jYiQg7vKjRNlO0/d.1223
+ test -e jYiQg7vKjRNlO0/r.1223
+ continue
+ :
+ test -e jYiQg7vKjRNlO0/d.1223
+ break
Hello, world!

exit $? #### AT THIS POINT!
+ exit 0
[?2004h[qha@ljmljat slwi]$ [?2004l
exit

Script done on 2021-01-02 16:09:00+09:00 [COMMAND_EXIT_CODE="0"]
